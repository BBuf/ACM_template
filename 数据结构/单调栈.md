# 单调栈

## 原理

单调栈与单调队列很相似。首先栈是后进先出的，单调性指的是严格的递增或者递减。

单调栈有以下两个性质：

1、若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。

2、越靠近栈顶的元素越后进栈。

单调栈与单调队列不同的地方在于栈只能在栈顶操作，因此一般在应用单调栈的地方不限定它的大小，否则会造成元素无法进栈。

元素进栈过程：对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把小于e或者等于e的元素弹出栈，直接遇到一个大于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是大于e或者等于e的元素。

一个单调递增栈的例子：

进栈元素分别为3，4，2，6，4，5，2，3

3进栈：（3）

3出栈，4进栈：（4）

2进栈：（4，2）

2出栈，4出栈，6进栈：（6）

4进栈：（6，4）

4出栈，5进栈：（6，5）

2进栈：（6，5，2）

2出栈，3进栈：（6，5，3）

以上左端为栈底，右端为栈顶。

## 例题

[POJ 2559 Largest Rectangle in a Histogram 单调栈模板](https://blog.csdn.net/just_sort/article/details/54092168)

给定从左到右多个矩形，已知这此矩形的宽度都为1，长度不完全相等。这些矩形相连排成一排，求在这些矩形包括的范围内能得到的面积最大的矩形，打印出该面积。所求矩形可以横跨多个矩形，但不能超出原有矩形所确定的范围。

建立一个单调递增栈，所有元素各进栈和出栈一次即可。每个元素出栈的时候更新最大的矩形面积。

设栈内的元素为一个二元组（x, y），x表示矩形的高度，y表示矩形的宽度。

若原始矩形高度分别为2,1,4,5,1,3,3

高度为2的元素进栈，当前栈为（2，1）

高度为1的元素准备进栈，但必须从栈顶开始删除高度大于或等于1的矩形，因为2已经不可能延续到当前矩形。删除（2，1）这个元素之后，更新最大矩形面积为2*1=2，然后把它的宽度1累加到当前高度为1的准备进栈的矩形，然后进栈，当前栈为（1，2）

高度为4的元素进栈，当前栈为（1，2） （4，1）

高度为5的元素进栈，当前栈为（1，2） （4，1） （5，1）

高度为1的元素准备进栈，删除（5，1）这个元素，更新最大矩形面积为5 * 1=5，把1累加到下一个元素，得到（4，2），删除（4，2），更新最大矩形面积为4 * 2=8，把2累加到下一个元素，得到（1，4），1 * 4 = 4 < 8，不必更新，删除（1，4），把4累加到当前准备进栈的元素然后进栈，当前栈为（1，5）

高度为3的元素进栈，当前栈为（1，5） （3，1）

高度为3的元素准备进栈，删除（3，1），不必更新，把1累加到当前准备进栈的元素然后进栈，当前栈为（1，5） （3，2）

把余下的元素逐个出栈，（3，2）出栈，不必更新，把2累加到下一个元素，当前栈为（1，7），（1，7）出栈，不必更新。栈空，结束。

最后的答案就是8。

```c++
struct node{
    int height, num;
}s[maxn];
int top;
int main()
{
    int n;
    while(scanf("%d", &n) != EOF)
    {
        if(n == 0) break;
        top = 0;
        LL ans = 0, tot , tmp, x;
        REP1(i, 0, n){
            scanf("%lld", &x);
            tmp = 0;
            while(top > 0 && s[top - 1].height >= x){
                tot = s[top - 1].height * (s[top - 1].num + tmp);
                if(tot > ans) ans = tot;
                tmp += s[top - 1].num;
                --top;
            }
            s[top].height = x;
            s[top].num = tmp + 1;
            ++top;
        }
        tmp = 0;
        while(top > 0){
            tot = s[top - 1].height * (s[top - 1].num + tmp);
            if(tot > ans) ans = tot;
            tmp += s[top - 1].num;
            --top;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```

[SPOJ_MINSUB:Largest_Submatrix](二分+单调栈)

给一个R*C的非负矩阵,试求出一个包含数字数>=K的子矩阵,使得这个子矩阵中最小的数字最大

主要是二分答案,即二分那个最小的数字,然后针对每次二分的值mid,可以将原矩阵根据是否满足A[i] [j]>=mid,而转成一个R*C的01矩阵a[][],然后问题求变成了给定一个二维01矩阵,求最大的满1矩阵,可以用单调栈的思想来处理这个子问题,设b[i] [j]表示从a[i] [j]的位置(包含)向上最多有几个连续的1存在
  比如 1 1 0
           1 0 1
的b[] []={{1,1,0},{2,0,1}}
然后对于每个i单独处理第i行(即子矩阵是以第i行为下边界的情况),设L[i] [j]表示从j开始向左满足b[i] [k]>=b[i] [j]条件所能延伸到的最大的位置,而R[i] [j]类似表示相应能够到的最右的位置
比如    j=1 2 3 4 5 6
           b[][j]=4 1 3 2 5 6
则lef[][]=1 1 3 3 5 6
 rig[][]=1 6 3 6 6 6

然后求lef[][]和rig[][]的过程对于每行可以运用单调栈在O(n)时限内完成。

```c++
int getmax(int x, int y)
{
    return x > y ? x : y;
}
int a[maxn][maxn], b[maxn][maxn], L[maxn][maxn], R[maxn][maxn], st[maxn];
int n, m, k, top;
 
int check(int x)
{
    int ans = 0;
    REP2(j, 1, m) b[1][j] = (a[1][j] >= x);
    REP2(i, 2, n){
        REP2(j, 1, m){
            b[i][j] = (a[i][j] >= x) ? (b[i - 1][j] + 1) : 0;
        }
    }
    REP2(i, 1, n){
        top = st[1] = L[i][1] = 1;
        REP2(j, 2, m){
            while(top > 0 && b[i][st[top]] >= b[i][j]) top--;
            L[i][j] = (top) ? (st[top] + 1) : 1; st[++top] = j;
        }
        top = 1;
        st[1] = R[i][m] = m;
        REP3(j, m - 1, 1){
            while(top > 0 && b[i][st[top]] >= b[i][j]) top--;
            R[i][j] = (top) ? (st[top] - 1) : m; st[++top] = j;
        }
        REP2(j, 1, m) if(b[i][j]) ans = getmax(ans, b[i][j] * (R[i][j] - L[i][j] + 1));
    }
    return ans;
}
 
int main()
{
    int T;
    scanf("%d", &T);
    while(T--){
        scanf("%d%d%d", &n, &m, &k);
        REP2(i, 1, n){
            REP2(j, 1, m){
                scanf("%d", &a[i][j]);
            }
        }
        int l = 0, r = 1e9;
        while(l < r){
            int mid = (l + r) / 2;
            if(check(mid) >= k) l = mid + 1;
            else r = mid;
        }
        printf("%d %d\n", l - 1, check(l - 1));
    }
    return 0;
}
```

